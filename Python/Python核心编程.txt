
下面是一个将输出重定向到日志文件的例子：
logfile = open('/tmp/mylog.txt', 'a')
print >> logfile, 'Fatal error: invalid input!'
logfile.close()

help(raw_input)

列表解析
squared = [x ** 2 for x in range(4)]
sqdEvens = [x ** 2 for x in range(8) if not x % 2]

在python中进行值的互换
>>> x, y = 1, 2
>>> x
1
>>> y
2
>>> x, y = y, x
>>> x
2
>>> y
1
在进行算法的循环运算中是否可以这样使用还需要测试

_xxx 不用'from module import *'导入
__xxx__系统定义名字
__xxx 类中的私有变量名
核心风格：避免用下划线作为变量名的开始
因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，我们建议程序员避
免用下划线作为变量名的开始。一般来讲，变量名_xxx 被看作是“私有的”，在模块或类外不
可以使用。当变量是私有的时候，用_xxx 来表示变量是很好的习惯。因为变量名__xxx__对
Python 来说有特殊含义，对于普通的变量应当避免这种命名风格。

# (1) 起始行(Unix)
# (2) 模块文档
# (3) 模块导入
# (4) 变量定义
# (5) 类定义
# (6) 函数定义
# (7) 主程序
(1) 起始行(#/usr/bin/env python)
通常只有在类Unix 环境下才使用起始行，有起始行就能够仅输入脚本名字来执行脚本，无需直接调用解释器。
(2)模块文档
简要介绍模块的功能及重要全局变量的含义，模块外可通过 module.__doc__ 访问这些内容。
(3)模块导入
导入当前模块的代码需要的所有模块；每个模块仅导入一次（当前模块被加载时）；函数内部的模块导入代码不会被执行， 除非该函数正在执行。
(4)变量定义
这里定义的变量为全局变量，本模块中的所有函数都可直接使用。从好的编程风格角度说，除非必须，否则就要尽量使用局部变量代替全局变量，如果坚持这样做，你的代码就不但容易维护，而且还可以提高性能并节省内存。
(5)类定义语句
所有的类都需要在这里定义。当模块被导入时class 语句会被执行, 类也就会被定义。类的文档变量是class.__doc__。
(6)函数定义语句
此处定义的函数可以通过module.function()在外部被访问到，当模块被导入时 def 语句会被执行， 函数也就都会定义好，函数的文档变量是function.__doc__。
(7) 主程序
无论这个模块是被别的模块导入还是作为脚本直接执行，都会执行这部分代码。通常这里不会有太多功能性代码，而是根据执行的模式调用不同的函数。

通常只有主程序模块中有大量的顶级可执行代码，所有其它被导入的模块只应该有很少的顶级执行代码，所有的功能代码都应该封装在函数或类当中。

如果模块是被导入， __name__ 的值为模块名字
如果模块是被直接执行， __name__ 的值为 '__main__'

python测试使用PyUnit也叫unittest模块

del 语句能够直接释放内存资源

import os
ls = os.linesep
fobj = open(fname, 'w')
fobj.writelines(['%s%s' % (x, ls) for x in all])
fobj.close()

核心技巧：使用局部变量替换模块变量
类似 os.linesep 这样的名字需要解释器做两次查询：（1）查找os 以确认它是一个模块，
（2）在这个模块中查找 linesep 变量。因为模块也是全局变量， 我们多消耗了系统资源。如
果你在一个函数中类似这样频繁使用一个属性，我们建议你为该属性取一个本地变量别名。 变
量查找速度将会快很多－－在查找全局变量之前， 总是先查找本地变量。 这也是一个让你的
程序跑的更快的技巧： 将经常用到的模块属性替换为一个本地引用。代码跑得更快，而也不用
老是敲那么长的变量名了。在我们的代码片段中，并没有定义函数，所以不能给你定义本地别
名的示例。不过我们有一个全局别名，至少也减少了一次名字查询

Python 代码风格指南（PEP8）, Python 快速参考和Python 常见问答都是开发者很重要的
“工具”。另外， 还有一些模块会帮助你成为一个优秀的Python 程序员。
Debugger: pdb
Logger: logging
Profilers: profile, hotshot, cProfile
调试模块 pdb 允许你设置（条件）断点，代码逐行执行，检查堆栈。它还支持事后调试。
logging 模块是在 Python2.3 中新增的， 它定义了一些函数和类帮助你的程序实现灵活
的日志系统。共有五级日志级别： 紧急， 错误，警告，信息和调试。
历史上，因为不同的人们为了满足不同的需求重复实现了很多性能测试器，Python 也有好
几个性能测试模块。 最早的 Python profile 模块是Python 写成的，用来测试函数的执行时
间，及每次脚本执行的总时间，既没有特定函数的执行时间也没有被包含的子函数调用时间。
在三个profile 模块中，它是最老的也是最慢的，尽管如此， 它仍然可以提供一些有价值的性
能信息。 hotshot 模块是在Python2.2 中新增的，它的目标是取代profile 模块， 它修复了
profile 模块的一些错误， 因为它是用C 语言写成，所以它有效的提高了性能。 注意 hotshot
重点解决了性能测试过载的问题， 但却需要更多的时间来生成结果。Python2.5 版修复了
hotshot 模块的一个关于时间计量的严重bug。
cProfile 模块是Python2.5 新增的， 它用来替换掉已经有历史的hotshot 和profile 模
块。被作者确认的它的一个较明显的缺点是它需要花较长时间从日志文件中载入分析结果， 不
支持子函数状态细节及某些结果不准。它也是用 C 语言来实现的。

3-1 标识符。为什么Python中不需要变量名和变量类型声明？
答：因为它们是动态类型，使用的时候自动进行类型声明。在Python语言中，对象的类型和内存占用都是运行时确定的。
3-2 标识符。为什么Python中不需要声明函数类型？
答：函数类型是一个动态类型返回值，在运行的时候确定
3-3 标识符。 为什么应当避免在变量名的开始和结尾使用双下划线？
答：因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号。
3-4 语句。 在Python中一行可以书写多个语句吗？
答： 分号(;),将两个语句写在一行，抑或更多行。
3-5 语句。 在Python中可以将一个语句分成多行书写吗？
答：反斜线(\)，继续上一行

>>> foostr = 'abcde'
>>> foostr[::-1]
'edcba'
>>> foostr[::-2]
'eca'
