
下面是一个将输出重定向到日志文件的例子：
logfile = open('/tmp/mylog.txt', 'a')
print >> logfile, 'Fatal error: invalid input!'
logfile.close()

help(raw_input)

列表解析
squared = [x ** 2 for x in range(4)]
sqdEvens = [x ** 2 for x in range(8) if not x % 2]

在python中进行值的互换
>>> x, y = 1, 2
>>> x
1
>>> y
2
>>> x, y = y, x
>>> x
2
>>> y
1
在进行算法的循环运算中是否可以这样使用还需要测试

_xxx 不用'from module import *'导入
__xxx__系统定义名字
__xxx 类中的私有变量名
核心风格：避免用下划线作为变量名的开始
因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，我们建议程序员避
免用下划线作为变量名的开始。一般来讲，变量名_xxx 被看作是“私有的”，在模块或类外不
可以使用。当变量是私有的时候，用_xxx 来表示变量是很好的习惯。因为变量名__xxx__对
Python 来说有特殊含义，对于普通的变量应当避免这种命名风格。

# (1) 起始行(Unix)
# (2) 模块文档
# (3) 模块导入
# (4) 变量定义
# (5) 类定义
# (6) 函数定义
# (7) 主程序
(1) 起始行(#/usr/bin/env python)
通常只有在类Unix 环境下才使用起始行，有起始行就能够仅输入脚本名字来执行脚本，无需直接调用解释器。
(2)模块文档
简要介绍模块的功能及重要全局变量的含义，模块外可通过 module.__doc__ 访问这些内容。
(3)模块导入
导入当前模块的代码需要的所有模块；每个模块仅导入一次（当前模块被加载时）；函数内部的模块导入代码不会被执行， 除非该函数正在执行。
(4)变量定义
这里定义的变量为全局变量，本模块中的所有函数都可直接使用。从好的编程风格角度说，除非必须，否则就要尽量使用局部变量代替全局变量，如果坚持这样做，你的代码就不但容易维护，而且还可以提高性能并节省内存。
(5)类定义语句
所有的类都需要在这里定义。当模块被导入时class 语句会被执行, 类也就会被定义。类的文档变量是class.__doc__。
(6)函数定义语句
此处定义的函数可以通过module.function()在外部被访问到，当模块被导入时 def 语句会被执行， 函数也就都会定义好，函数的文档变量是function.__doc__。
(7) 主程序
无论这个模块是被别的模块导入还是作为脚本直接执行，都会执行这部分代码。通常这里不会有太多功能性代码，而是根据执行的模式调用不同的函数。

通常只有主程序模块中有大量的顶级可执行代码，所有其它被导入的模块只应该有很少的顶级执行代码，所有的功能代码都应该封装在函数或类当中。

如果模块是被导入， __name__ 的值为模块名字
如果模块是被直接执行， __name__ 的值为 '__main__'

python测试使用PyUnit也叫unittest模块

del 语句能够直接释放内存资源

import os
ls = os.linesep
fobj = open(fname, 'w')
fobj.writelines(['%s%s' % (x, ls) for x in all])
fobj.close()

核心技巧：使用局部变量替换模块变量
类似 os.linesep 这样的名字需要解释器做两次查询：（1）查找os 以确认它是一个模块，
（2）在这个模块中查找 linesep 变量。因为模块也是全局变量， 我们多消耗了系统资源。如
果你在一个函数中类似这样频繁使用一个属性，我们建议你为该属性取一个本地变量别名。 变
量查找速度将会快很多－－在查找全局变量之前， 总是先查找本地变量。 这也是一个让你的
程序跑的更快的技巧： 将经常用到的模块属性替换为一个本地引用。代码跑得更快，而也不用
老是敲那么长的变量名了。在我们的代码片段中，并没有定义函数，所以不能给你定义本地别
名的示例。不过我们有一个全局别名，至少也减少了一次名字查询

Python 代码风格指南（PEP8）, Python 快速参考和Python 常见问答都是开发者很重要的
“工具”。另外， 还有一些模块会帮助你成为一个优秀的Python 程序员。
Debugger: pdb
Logger: logging
Profilers: profile, hotshot, cProfile
调试模块 pdb 允许你设置（条件）断点，代码逐行执行，检查堆栈。它还支持事后调试。
logging 模块是在 Python2.3 中新增的， 它定义了一些函数和类帮助你的程序实现灵活
的日志系统。共有五级日志级别： 紧急， 错误，警告，信息和调试。
历史上，因为不同的人们为了满足不同的需求重复实现了很多性能测试器，Python 也有好
几个性能测试模块。 最早的 Python profile 模块是Python 写成的，用来测试函数的执行时
间，及每次脚本执行的总时间，既没有特定函数的执行时间也没有被包含的子函数调用时间。
在三个profile 模块中，它是最老的也是最慢的，尽管如此， 它仍然可以提供一些有价值的性
能信息。 hotshot 模块是在Python2.2 中新增的，它的目标是取代profile 模块， 它修复了
profile 模块的一些错误， 因为它是用C 语言写成，所以它有效的提高了性能。 注意 hotshot
重点解决了性能测试过载的问题， 但却需要更多的时间来生成结果。Python2.5 版修复了
hotshot 模块的一个关于时间计量的严重bug。
cProfile 模块是Python2.5 新增的， 它用来替换掉已经有历史的hotshot 和profile 模
块。被作者确认的它的一个较明显的缺点是它需要花较长时间从日志文件中载入分析结果， 不
支持子函数状态细节及某些结果不准。它也是用 C 语言来实现的。

3-1 标识符。为什么Python中不需要变量名和变量类型声明？
答：因为它们是动态类型，使用的时候自动进行类型声明。在Python语言中，对象的类型和内存占用都是运行时确定的。
3-2 标识符。为什么Python中不需要声明函数类型？
答：函数类型是一个动态类型返回值，在运行的时候确定
3-3 标识符。 为什么应当避免在变量名的开始和结尾使用双下划线？
答：因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号。
3-4 语句。 在Python中一行可以书写多个语句吗？
答： 分号(;),将两个语句写在一行，抑或更多行。
3-5 语句。 在Python中可以将一个语句分成多行书写吗？
答：反斜线(\)，继续上一行

>>> foostr = 'abcde'
>>> foostr[::-1]
'edcba'
>>> foostr[::-2]
'eca'

a is b
这个表达式等价于下面的表达式
id(a) == id(b)

布尔逻辑运算符 and， or 和 not 都是Python 关键字，这些运算符的优先级按从高到低
的顺序列于表4.3. not 运算符拥有最高优先级，只比所有比较运算符低一级。 and 和 or 运
算符则相应的再低一级。

repr(obj) 或 `obj` 返回一个对象的字符串表示
str(obj) 返回对象适合可读性好的字符串表示
type(obj) 得到一个对象的类型，并返回相应的type 对象
cmp(obj1, obj2)用于比较两个对象obj1 和obj2， 如果obj1 小于obj2, 则返回一个负整
数，如果obj1 大于obj2 则返回一个正整数， 如果obj1 等于obj2， 则返回0。

str()函数得到的字符串可读性好， 而repr()函数得到的字符
串通常可以用来重新获得该对象, 通常情况下 obj == eval(repr(obj)) 这个等式是成立的。

解释器不得不首先查找types 这个模块
的名字，然后在该模块的字典中查找IntType。通过使用from-import，你可以减少一次查询：
from types import IntType
if isinstance(num, int) # 如果num的类型是int

数据类型 存储模型 更新模型 访问模型
数字 Scalar 不可更改 直接访问
字符串 Scalar 不可更改 顺序访问
列表 Container 可更改 顺序访问
元组 Container 不可更改 顺序访问
字典 Container 可更改 映射访问

Python 没有 char 或 byte 类型来保存单一字符或8 比特整数。你可以使用长度为1 的字
符串表示字符或8 比特整数。

对那些宁愿放弃更大的取值范围而需要更高精确度的
用户来说， Python 还有一种十进制浮点数类型 Decimal， 不过你必须导入decimal 模块才可
以使用它。浮点数总是不精确的。Decimals 则拥有任意的精度。在处理金钱这类确定的值时，
Decimal 类型就很有用。

from __future__ import division 使整数可以直接进行除法，例：1/2=0.5

coerce()，数据类型转换函数
>>>coerce(1.3, 134L)
(1.3, 134.0)
divmod()内建函数把除法和取余运算结合起来, 返回一个包含商和余数的元组
>>> divmod(10,3)
(3, 1)
内建函数round()用于对浮点数进行四舍五入运算。它有一个可选的小数位数参数。如果
不提供小数位参数， 它返回与第一个参数最接近的整数（但仍然是浮点类型）。第二个参数告
诉round 函数将结果精确到小数点后指定位数。

函数 int()直接截去小数部分。（返回值为整数）
函数 floor()得到最接近原数但小于原数的整数。（返回值为浮点数）
函数 round()得到最接近原数的整数。（返回值为浮点数）
abs(num) 返回 num 的绝对值
coerce(num1, num2) 将num1和num2转换为同一类型，然后以一个 元组的形式返回。
divmod(num1, num2) 除法－取余运算的结合。返回一个元组(num1/num2,num1 % num2)。
对浮点数和复数的商进行下舍入（复数仅取实数部分的商）

pow(num1, num2, mod=1) 取 num1 的 num2次方，如果提供 mod参数，则计算结果再对mod进行取余运算
round(flt, ndig=0) 接受一个浮点数 flt 并对其四舍五入，保存 ndig位小数。若不提供ndig 参数，则默认小数点后0位。

Python 还提供了两个内建函数来返回字符串表示的8 进制和16 进制整数。它们分别是 oct()
和 hex()。它们都接受一个整数（任意进制的）对象，并返回一个对应值的字符串对象。

函数chr()接受一个单字节整数值，返回一个字符串，
unichr()，unichr()跟它一样，只不过返回的是Unicode 字符
unicode()和unichar()可以看成Unicode 版本的str()和chr()
其值为对应的字符。函数ord()则相反，它接受一个字符，返回其对应的整数值。
>>> chr(97)
'a'
>>> ord('a')
97


decimal 十进制浮点运算类 Decimal
array 高效数值数组（字符，整数，浮点数等等）
math/cmath 标准C库数学运算函数。常规数学运算在match模块，复数运算在cmath模块
operator 数字运算符的函数实现。比如 tor.sub(m,n)等价于 m - n
random 多种伪随机数生成器

两个整数参数，返回二者之间的随机整数
randrange() 它接受和 range() 函数一样的参数， 随机返回range([start,]stop[,step])结果的一项
randrange(10)  或  randrange(0，10)
uniform() 几乎和 randint()一样，不过它返回的是二者之间的一个浮点数(不包括范围上限)。
uniform(0, 10)
random() 类似 uniform() 只不过下限恒等于0.0，上限恒等于1.0
random()
choice() 随机返回给定序列（关于序列，见第六章）的一个元素
choice(list)



